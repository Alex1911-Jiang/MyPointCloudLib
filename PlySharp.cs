using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace Ply
{
    public class PlySharp<TPosition> where TPosition : struct
    {
        public Format Format { get; }
        public List<PlyPosition<TPosition>> Positions = new List<PlyPosition<TPosition>>();
        public PlySharp(Format format)
        {
            Format = format;
        }

        public virtual void AddPoint(TPosition x, TPosition y, TPosition z)
        {
            Positions.Add(new PlyPosition<TPosition>(x, y, z));
        }
        public virtual void AddPoint(PlyPosition<TPosition> pos)
        {
            Positions.Add(pos);
        }

        internal string GetTypeAndName<T>() where T : struct
        {
            if (typeof(T) == typeof(sbyte))
                return "char";
            else if (typeof(T) == typeof(byte))
                return "uchar";
            else if (typeof(T) == typeof(short))
                return "short";
            else if (typeof(T) == typeof(ushort))
                return "ushort";
            else if (typeof(T) == typeof(int))
                return "int";
            else if (typeof(T) == typeof(uint))
                return "uint";
            else if (typeof(T) == typeof(float))
                return "float";
            else if (typeof(T) == typeof(double))
                return "double";
            throw new Exception($@"不支持的数据类型，请改用以下数据类型：
{typeof(sbyte).Name},
{typeof(byte).Name},
{typeof(short).Name},
{typeof(ushort).Name},
{typeof(int).Name},
{typeof(uint).Name},
{typeof(float).Name},
{typeof(double).Name}。");
        }

        internal void WriteBinaryLittleEndianToStream<T>(BinaryWriter bw, T data) where T : struct
        {
            if (data is sbyte sbyteData)
                bw.Write(sbyteData);
            else if (data is byte byteData)
                bw.Write(byteData);
            else if (data is short shorData)
                bw.Write(shorData);
            else if (data is ushort ushortData)
                bw.Write(ushortData);
            else if (data is int intData)
                bw.Write(intData);
            else if (data is uint uintData)
                bw.Write(uintData);
            else if (data is float floatData)
                bw.Write(floatData);
            else if (data is double doubleData)
                bw.Write(doubleData);
            else
                throw new Exception($@"不支持的数据类型，请改用以下数据类型：
{typeof(sbyte).Name},
{typeof(byte).Name},
{typeof(short).Name},
{typeof(ushort).Name},
{typeof(int).Name},
{typeof(uint).Name},
{typeof(float).Name},
{typeof(double).Name}。");
        }

        internal void WriteBinaryBigEndianToStream<T>(BinaryWriter bw, T data) where T : struct
        {
            if (data is byte byteData)
            {
                bw.Write(byteData);
            }
            else if (data is sbyte sbyteData)
                bw.Write(sbyteData);
            else
            {
                byte[] bytes;
                if (data is short shorData)
                    bytes = BitConverter.GetBytes(shorData);
                else if (data is ushort ushortData)
                    bytes = BitConverter.GetBytes(ushortData);
                else if (data is int intData)
                    bytes = BitConverter.GetBytes(intData);
                else if (data is uint uintData)
                    bytes = BitConverter.GetBytes(uintData);
                else if (data is float floatData)
                    bytes = BitConverter.GetBytes(floatData);
                else if (data is double doubleData)
                    bytes = BitConverter.GetBytes(doubleData);
                else
                    throw new Exception($@"不支持的数据类型，请改用以下数据类型：
{typeof(sbyte).Name},
{typeof(byte).Name},
{typeof(short).Name},
{typeof(ushort).Name},
{typeof(int).Name},
{typeof(uint).Name},
{typeof(float).Name},
{typeof(double).Name}。");

                bytes = bytes.Reverse().ToArray();
                bw.Write(bytes);
            }
        }

        public virtual void BuildToStream(Stream stream)
        {
            using BinaryWriter bw = new BinaryWriter(stream);
            string header = $@"ply
format {Format} 1.0
comment generated by Alex1911
element vertex {Positions.Count}
property {GetTypeAndName<TPosition>()} x
property {GetTypeAndName<TPosition>()} y
property {GetTypeAndName<TPosition>()} z
end_header
";
            byte[] headerBytes = Encoding.ASCII.GetBytes(header);
            bw.Write(headerBytes);

            if (Format == Format.binary_little_endian)
            {
                for (int i = 0; i < Positions.Count; i++)
                {
                    WriteBinaryLittleEndianToStream(bw, Positions[i].X);
                    WriteBinaryLittleEndianToStream(bw, Positions[i].Y);
                    WriteBinaryLittleEndianToStream(bw, Positions[i].Z);
                }
            }
            else if (Format == Format.binary_big_endian)
            {
                for (int i = 0; i < Positions.Count; i++)
                {
                    WriteBinaryBigEndianToStream(bw, Positions[i].X);
                    WriteBinaryBigEndianToStream(bw, Positions[i].Y);
                    WriteBinaryBigEndianToStream(bw, Positions[i].Z);
                }
            }
            else if (Format == Format.ascii)
            {
                StringBuilder sb = new StringBuilder();
                for (int i = 0; i < Positions.Count; i++)
                {
                    sb.Append($"{Positions[i].X} {Positions[i].Y} {Positions[i].Z}\n");
                }
                byte[] dataBytes = Encoding.ASCII.GetBytes(sb.ToString());
                bw.Write(dataBytes);
            }
        }

        public virtual void BuildToFile(string fileName)
        {
            using FileStream fs = new FileStream(fileName, FileMode.OpenOrCreate, FileAccess.Write);
            BuildToStream(fs);
        }

        public virtual byte[] BuildAsBytes()
        {
            using MemoryStream ms = new MemoryStream();
            BuildToStream(ms);
            return ms.ToArray();
        }
    }

    public class PlySharp<TPosition, TColor> : PlySharp<TPosition> where TPosition : struct where TColor : struct
    {
        public List<IColorStruct<TColor>> Colors = new List<IColorStruct<TColor>>();
        public PlySharp(Format format) : base(format)
        {
        }

        public void AddPointAndColor(TPosition x, TPosition y, TPosition z, TColor red, TColor green, TColor blue)
        {
            AddPoint(x, y, z);
            AddColor(red, green, blue);
        }

        public void AddPointAndColor(TPosition x, TPosition y, TPosition z, TColor red, TColor green, TColor blue, TColor alpha)
        {
            AddPoint(x, y, z);
            AddColor(red, green, blue, alpha);
        }

        public void AddPointAndColor(PlyPosition<TPosition> pos, PlyColor<TColor> color)
        {
            AddPoint(pos);
            AddColor(color);
        }

        public void AddPointAndColor(PlyPosition<TPosition> pos, PlyColorWithAlpha<TColor> color)
        {
            AddPoint(pos);
            AddColor(color);
        }

        public void AddColor(TColor red, TColor green, TColor blue)
        {
            Colors.Add(new PlyColor<TColor>(red, green, blue));
        }

        public void AddColor(PlyColor<TColor> color)
        {
            Colors.Add(color);
        }

        public void AddColor(TColor red, TColor green, TColor blue, TColor alpha)
        {
            Colors.Add(new PlyColorWithAlpha<TColor>(red, green, blue, alpha));
        }

        public void AddColor(PlyColorWithAlpha<TColor> color)
        {
            Colors.Add(color);
        }

        public override void BuildToStream(Stream stream)
        {
            if (Positions.Count != Colors.Count)
            {
                throw new Exception("点数量和颜色数量不一致。");
            }
            using BinaryWriter bw = new BinaryWriter(stream);
            string header = $@"ply
format {Format} 1.0
comment generated by Alex1911
element vertex {Positions.Count}
property {GetTypeAndName<TPosition>()} x
property {GetTypeAndName<TPosition>()} y
property {GetTypeAndName<TPosition>()} z
property {GetTypeAndName<TColor>()} red
property {GetTypeAndName<TColor>()} green
property {GetTypeAndName<TColor>()} blue
end_header
";
            byte[] headerBytes = Encoding.ASCII.GetBytes(header);
            bw.Write(headerBytes);

            if (Format == Format.binary_little_endian)
            {
                for (int i = 0; i < Positions.Count; i++)
                {
                    WriteBinaryLittleEndianToStream(bw, Positions[i].X);
                    WriteBinaryLittleEndianToStream(bw, Positions[i].Y);
                    WriteBinaryLittleEndianToStream(bw, Positions[i].Z);
                    WriteBinaryLittleEndianToStream(bw, Colors[i].Red);
                    WriteBinaryLittleEndianToStream(bw, Colors[i].Green);
                    WriteBinaryLittleEndianToStream(bw, Colors[i].Blue);
                    if (Colors[i] is PlyColorWithAlpha<TColor> colorWithAlpha)
                        WriteBinaryLittleEndianToStream(bw, colorWithAlpha.Alpha);
                }
            }
            else if (Format == Format.binary_big_endian)
            {
                for (int i = 0; i < Positions.Count; i++)
                {
                    WriteBinaryBigEndianToStream(bw, Positions[i].X);
                    WriteBinaryBigEndianToStream(bw, Positions[i].Y);
                    WriteBinaryBigEndianToStream(bw, Positions[i].Z);
                    WriteBinaryBigEndianToStream(bw, Colors[i].Red);
                    WriteBinaryBigEndianToStream(bw, Colors[i].Green);
                    WriteBinaryBigEndianToStream(bw, Colors[i].Blue);
                    if (Colors[i] is PlyColorWithAlpha<TColor> colorWithAlpha)
                        WriteBinaryBigEndianToStream(bw, colorWithAlpha.Alpha);
                }
            }
            else if (Format == Format.ascii)
            {
                StringBuilder sb = new StringBuilder();
                for (int i = 0; i < Positions.Count; i++)
                {
                    string alpha = "";
                    if (Colors[i] is PlyColorWithAlpha<TColor> colorWithAlpha)
                    {
                        alpha = $" {colorWithAlpha.Alpha}";
                    }
                    sb.Append($"{Positions[i].X} {Positions[i].Y} {Positions[i].Z} {Colors[i].Red} {Colors[i].Green} {Colors[i].Blue}{alpha}\n");
                }
                byte[] dataBytes = Encoding.ASCII.GetBytes(sb.ToString());
                bw.Write(dataBytes);
            }
        }
    }


    public struct PlyPosition<T>
    {
        public PlyPosition(T x, T y, T z)
        {
            X = x;
            Y = y;
            Z = z;
        }
        public T X { get; set; }
        public T Y { get; set; }
        public T Z { get; set; }
    }

    public struct PlyColor<T> : IColorStruct<T> where T : struct
    {
        public PlyColor(T red, T green, T blue)
        {
            Red = red;
            Green = green;
            Blue = blue;
        }
        public T Red { get; set; }
        public T Green { get; set; }
        public T Blue { get; set; }
    }

    public struct PlyColorWithAlpha<T> : IColorStruct<T> where T : struct
    {
        public PlyColorWithAlpha(T red, T green, T blue, T alpha)
        {
            Red = red;
            Green = green;
            Blue = blue;
            Alpha = alpha;
        }
        public T Red { get; set; }
        public T Green { get; set; }
        public T Blue { get; set; }
        public T Alpha { get; set; }
    }

    public enum Format
    {
        binary_little_endian,
        ascii,
        binary_big_endian,
    }

    public interface IColorStruct<T> where T : struct
    {
        public T Red { get; set; }
        public T Green { get; set; }
        public T Blue { get; set; }
    }
}
